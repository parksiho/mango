<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mango Runner 2.0 🐶🌸</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: linear-gradient(skyblue, lightgreen);
    font-family: Arial, sans-serif;
    touch-action: manipulation;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #87ceeb;
    max-width: 100vw;
    max-height: 100vh;
  }
  
  /* 모바일 화면 대응 */
  @media (max-width: 768px) {
    #gameCanvas {
      width: 100vw;
      height: 50vh;
    }
  }
  
  /* 터치 안내 메시지 */
  .touch-hint {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 1000;
    pointer-events: none;
  }
  
  @media (min-width: 769px) {
    .touch-hint {
      display: none;
    }
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="300"></canvas>
<div class="touch-hint">화면을 터치해서 점프하세요!</div>
<audio id="bgm" loop autoplay>
  <source src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_7f1f03a2cf.mp3?filename=happy-day-110997.mp3" type="audio/mpeg">
</audio>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const bgm = document.getElementById("bgm");

// 모바일 화면 크기에 맞게 캔버스 크기 조정
function resizeCanvas() {
  const isMobile = window.innerWidth <= 768;
  if (isMobile) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.5; // 화면 높이의 50%
  } else {
    canvas.width = 800;
    canvas.height = 300;
  }
}

// 초기 캔버스 크기 설정
resizeCanvas();

// 화면 크기 변경 시 캔버스 크기 재조정
window.addEventListener('resize', resizeCanvas);

let dog = { x: 50, y: canvas.height - 70, width: 50, height: 50, vy: 0, jumping: false, rotation: 0, doubleJumpUsed: false };
let gravity = 0.8;
let obstacles = [];
let snacks = [];
let coinSpawnCounter = 0; // 코인 생성 카운터
let frame = 0;
let speed = 4.5; // 게임 속도를 10% 느리게 조정 (5 * 0.9 = 4.5)
let score = 0;
let gameOver = false;
let gameStarted = true;

// 망고 이미지 로드
let mangoImage = new Image();
let imageLoaded = false;
mangoImage.src = "https://raw.githubusercontent.com/parksiho/mango/main/mg1.png";
mangoImage.onload = function() {
  console.log("망고 이미지 로드 완료!");
  imageLoaded = true;
};
mangoImage.onerror = function() {
  console.log("망고 이미지 로드 실패 - 기본 모양으로 표시됩니다.");
  imageLoaded = false;
};

// 구름 위치
let clouds = [
  { x: 100, y: 50 },
  { x: 400, y: 30 },
  { x: 700, y: 70 }
];

// 게임 재시작 함수
function restartGame() {
  // 모든 게임 상태 초기화
  dog = { x: 50, y: canvas.height - 70, width: 50, height: 50, vy: 0, jumping: false, rotation: 0 };
  obstacles = [];
  snacks = [];
  coinSpawnCounter = 0;
  frame = 0;
  speed = 4.5; // 게임 속도를 10% 느리게 조정
  score = 0;
  gameOver = false;
  gameStarted = true;
  
  // 구름 위치도 초기화
  clouds = [
    { x: 100, y: 50 },
    { x: 400, y: 30 },
    { x: 700, y: 70 }
  ];
}

function drawBackground() {
  const groundY = canvas.height - 20;
  const skyHeight = groundY;
  
  // 하늘
  ctx.fillStyle = "#87ceeb";
  ctx.fillRect(0, 0, canvas.width, skyHeight);
  
  // 구름
  ctx.fillStyle = "white";
  for (let c of clouds) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, 20, 0, Math.PI * 2);
    ctx.arc(c.x + 25, c.y + 10, 20, 0, Math.PI * 2);
    ctx.arc(c.x - 25, c.y + 10, 20, 0, Math.PI * 2);
    ctx.fill();
    c.x -= 1;
    if (c.x < -50) c.x = canvas.width + 50;
  }
  
  // 땅
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, groundY, canvas.width, 20);
}

function drawDog() {
  if (imageLoaded && mangoImage.complete) {
    // 이미지가 로드된 경우 회전하여 그리기
    ctx.save();
    ctx.translate(dog.x + dog.width/2, dog.y + dog.height/2);
    ctx.rotate(dog.rotation);
    ctx.drawImage(mangoImage, -dog.width/2, -dog.height/2, dog.width, dog.height);
    ctx.restore();
  } else {
    // 이미지가 로드되지 않은 경우 기본 원형으로 표시
    ctx.fillStyle = "#f4a460";
    ctx.beginPath();
    ctx.arc(dog.x + 25, dog.y + 25, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(dog.x + 35, dog.y + 15, 5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawObstacles() {
  ctx.fillStyle = "#2e8b57";
  for (let o of obstacles) ctx.fillRect(o.x, o.y, o.width, o.height);
}

function drawSnacks() {
  ctx.fillStyle = "#ffa500";
  for (let s of snacks) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();

  // 게임 오버 상태가 아니면 게임 진행
  if (!gameOver) {
    // 강아지 점프
    dog.y += dog.vy;
    dog.vy += gravity;
    
    // 점프 중일 때 회전 애니메이션 (한 바퀴 회전)
    if (dog.jumping) {
      dog.rotation += 0.3; // 회전 속도 조절
      if (dog.rotation >= Math.PI * 2) {
        dog.rotation = 0; // 한 바퀴 완료 후 초기화
      }
    }
    
    if (dog.y >= canvas.height - 70) {
      dog.y = canvas.height - 70;
      dog.vy = 0;
      dog.jumping = false;
      dog.doubleJumpUsed = false; // 착지 시 2단 점프 상태 초기화
      dog.rotation = 0; // 착지 시 회전 초기화
    }

    // 장애물 생성
    if (frame % 90 === 0) {
      obstacles.push({ x: canvas.width, y: canvas.height - 50, width: 20, height: 30 });
    }

    // 코인 생성 로직 개선 - 많이/적게 나오는 패턴을 적절히 섞기
    coinSpawnCounter++;
    
    // 코인 생성 패턴: 짧은 간격(많이)과 긴 간격(적게)을 섞어서 생성
    let shouldSpawnCoin = false;
    
    if (coinSpawnCounter % 60 === 0) {
      // 짧은 간격으로 코인 생성 (많이 나오는 구간)
      shouldSpawnCoin = true;
    } else if (coinSpawnCounter % 200 === 0) {
      // 긴 간격으로 코인 생성 (적게 나오는 구간)
      shouldSpawnCoin = true;
    }
    
    if (shouldSpawnCoin) {
      // 코인 위치를 장애물과 너무 가깝지 않게 조정
      let coinY = canvas.height - 100;
      let coinX = canvas.width;
      
      // 장애물과의 거리 확인 (최소 100픽셀 이상 떨어뜨림)
      let tooCloseToObstacle = false;
      for (let obstacle of obstacles) {
        if (Math.abs(obstacle.x - coinX) < 100) {
          tooCloseToObstacle = true;
          break;
        }
      }
      
      // 장애물과 너무 가깝지 않을 때만 코인 생성
      if (!tooCloseToObstacle) {
        snacks.push({ x: coinX, y: coinY });
      }
    }

    // 이동
    for (let o of obstacles) o.x -= speed;
    for (let s of snacks) s.x -= speed;

    // 충돌
    for (let o of obstacles) {
      if (dog.x < o.x + o.width &&
          dog.x + dog.width > o.x &&
          dog.y < o.y + o.height &&
          dog.y + dog.height > o.y) {
        gameOver = true;
        const isMobile = window.innerWidth <= 768;
        const restartHint = isMobile ? "화면을 터치해서 다시 시작하세요!" : "스페이스바를 눌러 다시 시작하세요!";
        alert("💥 망고가 돌부리에 걸렸어요! 점수: " + score + "\n\n" + restartHint);
      }
    }

    // 코인 먹기 - 점수를 100점씩 추가
    for (let i = snacks.length - 1; i >= 0; i--) {
      let s = snacks[i];
      if (Math.abs(dog.x - s.x) < 30 && Math.abs(dog.y - s.y) < 30) {
        snacks.splice(i, 1);
        score += 100; // 코인 점수를 100점으로 변경
      }
    }

    // 점수 증가
    score++;
  }

  // 그리기
  drawDog();
  drawObstacles();
  drawSnacks();

  // 점수 표시
  ctx.fillStyle = "black";
  ctx.font = "20px Arial";
  ctx.fillText("점수: " + score, 10, 25);
  
  // 이미지 로드 상태 표시 (디버깅용)
  if (!imageLoaded) {
    ctx.fillStyle = "red";
    ctx.font = "12px Arial";
    ctx.fillText("이미지 로딩 중...", 10, canvas.height - 10);
  }

  // 게임 오버 메시지 표시
  if (gameOver) {
    ctx.fillStyle = "red";
    ctx.font = "30px Arial";
    ctx.textAlign = "center";
    ctx.fillText("게임 오버!", canvas.width / 2, canvas.height / 2 - 20);
    ctx.fillStyle = "black";
    ctx.font = "16px Arial";
    const isMobile = window.innerWidth <= 768;
    const restartText = isMobile ? "화면을 터치해서 다시 시작" : "스페이스바를 눌러 다시 시작";
    ctx.fillText(restartText, canvas.width / 2, canvas.height / 2 + 20);
    ctx.textAlign = "left";
  }

  frame++;
  requestAnimationFrame(update);
}

// 점프 함수 - 2단 점프 구현
function jump() {
  if (gameOver) {
    // 게임 오버 상태에서 점프하면 재시작
    restartGame();
  } else if (!dog.jumping) {
    // 첫 번째 점프
    dog.vy = -13;
    dog.jumping = true;
    dog.doubleJumpUsed = false;
  } else if (dog.jumping && !dog.doubleJumpUsed) {
    // 두 번째 점프 (2단 점프)
    dog.vy = -13;
    dog.doubleJumpUsed = true;
  }
}

// 키보드 이벤트
document.addEventListener("keydown", e => {
  if (e.code === "Space") {
    jump();
  }
});

// 터치 이벤트
document.addEventListener("touchstart", e => {
  e.preventDefault(); // 스크롤 방지
  jump();
});

// 마우스 클릭 이벤트 (데스크톱에서도 클릭으로 점프 가능)
document.addEventListener("click", e => {
  if (e.target === canvas) {
    jump();
  }
});

// 음악 자동 재생 시도
document.addEventListener("click", () => {
  bgm.play().catch(() => {});
});

update();
</script>
</body>
</html>